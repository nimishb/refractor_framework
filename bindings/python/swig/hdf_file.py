# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_hdf_file', [dirname(__file__)])
        except ImportError:
            import _hdf_file
            return _hdf_file
        if fp is not None:
            try:
                _mod = imp.load_module('_hdf_file', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _hdf_file = swig_import_helper()
    del swig_import_helper
else:
    import _hdf_file
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_hdf_file.SHARED_PTR_DISOWN_swigconstant(_hdf_file)
SHARED_PTR_DISOWN = _hdf_file.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class HdfFile(full_physics_swig.generic_object.GenericObject):
    """

    This class reads and writes a HDF5 file.

    Note that this is just a thin layer on top of the HDF 5 libraries to
    make the file operations we need to do in Level 2 Full Physics easier.
    There are many other things that can be done with a HDF 5 than what
    this class exposes.

    Note that because it is what is used by Level 2 product, we produce
    data in 32 bit (either 32 bit integer or 32 bit floating point). On a
    64 bit system, the underlying double and int are larger. We map
    between these types as needed transparently.

    HDF supports both fixed length strings and variable length strings. We
    have the need to write both variable length strings and fixed length
    strings. As a convention, if std::string are passed we write as
    variable length. If const char* is passed, we determine the fixed
    length needed to accommodate the largest string passed and write the
    data as fixed strings of that length (padding shorter strings with
    spaces). This is an arbitrary decision, but it allows us to write both
    types.

    Note that in what is a fairly odd convention, we add a trailing
    '\\0' in our fixed length string, so there is one extra character.

    C++ includes: hdf_file.h 
    """

    __swig_setmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HdfFile, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HdfFile, name)
    __repr__ = _swig_repr

    def __str__(self):
        return _hdf_file.HdfFile___str__(self)
    READ = _hdf_file.HdfFile_READ
    CREATE = _hdf_file.HdfFile_CREATE
    READ_WRITE = _hdf_file.HdfFile_READ_WRITE

    def __init__(self, *args):
        """

        FullPhysics::HdfFile::HdfFile(const std::string &Fname, Mode M=READ)

        """
        this = _hdf_file.new_HdfFile(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def close(self):
        """

        void FullPhysics::HdfFile::close()
        Close the underlying file.

        This is automatically done by the destructor, so you only need to call
        this if you want to force a close (e.g., for a unit test) 
        """
        return _hdf_file.HdfFile_close(self)


    def has_object(self, Objname):
        """

        bool FullPhysics::HdfFile::has_object(const std::string &Objname) const
        Check to see if an object (such as a Dataset) is in the file. 
        """
        return _hdf_file.HdfFile_has_object(self, Objname)


    def has_attribute(self, Aname):
        """

        bool FullPhysics::HdfFile::has_attribute(const std::string &Aname) const
        Check to see if a attribute is in the file. 
        """
        return _hdf_file.HdfFile_has_attribute(self, Aname)


    def _v_file_name(self):
        """

        const std::string& FullPhysics::HdfFile::file_name() const
        File name. 
        """
        return _hdf_file.HdfFile__v_file_name(self)


    @property
    def file_name(self):
        return self._v_file_name()


    def _v_mode(self):
        """

        Mode FullPhysics::HdfFile::mode() const
        Mode file was opened with. 
        """
        return _hdf_file.HdfFile__v_mode(self)


    @property
    def mode(self):
        return self._v_mode()


    def is_hdf(Fname):
        """

        static bool FullPhysics::HdfFile::is_hdf(const std::string &Fname)
        Return true if the given file is an HDF file. 
        """
        return _hdf_file.HdfFile_is_hdf(Fname)

    if _newclass:
        is_hdf = staticmethod(is_hdf)
    __swig_getmethods__["is_hdf"] = lambda x: is_hdf

    def write_double_1d(self, fname, D):
        return _hdf_file.HdfFile_write_double_1d(self, fname, D)

    def write_double_2d(self, fname, D):
        return _hdf_file.HdfFile_write_double_2d(self, fname, D)

    def write_double_3d(self, fname, D):
        return _hdf_file.HdfFile_write_double_3d(self, fname, D)

    def write_double_4d(self, fname, D):
        return _hdf_file.HdfFile_write_double_4d(self, fname, D)

    def read_double_1d(self, fname):
        return _hdf_file.HdfFile_read_double_1d(self, fname)

    def read_double_2d(self, fname):
        return _hdf_file.HdfFile_read_double_2d(self, fname)

    def read_double_3d(self, fname):
        return _hdf_file.HdfFile_read_double_3d(self, fname)

    def read_double_4d(self, fname):
        return _hdf_file.HdfFile_read_double_4d(self, fname)

    def read_int_1d(self, fname):
        return _hdf_file.HdfFile_read_int_1d(self, fname)

    def read_int_2d(self, fname):
        return _hdf_file.HdfFile_read_int_2d(self, fname)

    def read_int_3d(self, fname):
        return _hdf_file.HdfFile_read_int_3d(self, fname)

    def read_int_4d(self, fname):
        return _hdf_file.HdfFile_read_int_4d(self, fname)

    def read_double_with_unit_1d(self, fname):
        return _hdf_file.HdfFile_read_double_with_unit_1d(self, fname)

    def read_double_with_unit_2d(self, fname):
        return _hdf_file.HdfFile_read_double_with_unit_2d(self, fname)

    def read_double_with_unit_3d(self, fname):
        return _hdf_file.HdfFile_read_double_with_unit_3d(self, fname)

    def read_double_with_unit_4d(self, fname):
        return _hdf_file.HdfFile_read_double_with_unit_4d(self, fname)

    @classmethod
    def pickle_format_version(cls):
      return 1

    def __reduce__(self):
      return _new_from_init, (self.__class__, 1, self.file_name,self.mode)

    __swig_destroy__ = _hdf_file.delete_HdfFile
    __del__ = lambda self: None
HdfFile_swigregister = _hdf_file.HdfFile_swigregister
HdfFile_swigregister(HdfFile)

def HdfFile_is_hdf(Fname):
    """

    static bool FullPhysics::HdfFile::is_hdf(const std::string &Fname)
    Return true if the given file is an HDF file. 
    """
    return _hdf_file.HdfFile_is_hdf(Fname)

# This file is compatible with both classic and new-style classes.


