# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_heritage_file', [dirname(__file__)])
        except ImportError:
            import _heritage_file
            return _heritage_file
        if fp is not None:
            try:
                _mod = imp.load_module('_heritage_file', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _heritage_file = swig_import_helper()
    del swig_import_helper
else:
    import _heritage_file
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_heritage_file.SHARED_PTR_DISOWN_swigconstant(_heritage_file)
SHARED_PTR_DISOWN = _heritage_file.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class HeritageFile(full_physics_swig.generic_object.GenericObject):
    """

    This class reads the heritage file formats.

    We read both the configuration file and the matrix files (there are
    similar enough in format that it makes sense to combine these two).

    For the configuration files, we provide the values using a "keyword
    path". By convention, this is just the keywords separated by a "/".
    For example, "CONTROL/input_file". Note that the keyword path is
    case insensitive, so "CONTROL/input_file" and "control/INPUT_FILE"
    are the same.

    Some blocks are special in that there can be more than one of them.
    This includes "GAS", "INSTRUMENT", "AEROSOL" and "WINDOW". For
    blocks that we encounter more than one of, we access the data use a
    "index" number, which must be between 0 and the
    number_block(keyword). You can also view this data by adding the name
    to the keyword, so to find the moment file for the aerosol "IC" you
    can look at "PARAMETER_DEFINITION/AEROSOL/IC/moment_file". The two
    interfaces give the same data, use whichever is more convenient.

    For the various "HEADER" format (i.e., the matrix file), we just use
    the keyword with no path, for example "Number_rows".

    We have an blitz Array "double". This is empty unless the file we
    read happens to contain matrix data.

    We support conversion of the values read to a variety of formats. This
    is done by the "value" function. Currently supported conversions:

    Any type that boost::lexical_cast<T> can convert a string to. In
    particular, double and int

    A string. This includes stripping the quotes that may appear around
    the value

    A boolean type. We translate the string "true" to true and "false"
    to false.

    A std::vector<double>, which converts a list of doubles.

    A std::vector<int>, which converts to a list of ints. This supports
    ranges in the entry, e.g. "1:4 7" which is returned as the list 1,
    2, 3, 4, 7.

    A std::vector<std::string>, which converts a set of strings where each
    is quoted.

    A Time for a time stamp.

    Some of the values may be file names. The file and directory names are
    relative to the location of the heritage file. The routine file_value
    handles adding any necessary paths to the values found in the file.

    In addition, file_value will expand out environment variables like
    "$(abscodir)".

    C++ includes: heritage_file.h 
    """

    __swig_setmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HeritageFile, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HeritageFile, name)
    __repr__ = _swig_repr

    def __init__(self, Fname):
        """

        FullPhysics::HeritageFile::HeritageFile(const std::string &Fname)

        """
        this = _heritage_file.new_HeritageFile(Fname)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def __str__(self):
        return _heritage_file.HeritageFile___str__(self)

    def parse_file(self, Fname):
        """

        void FullPhysics::HeritageFile::parse_file(const std::string &Fname)

        """
        return _heritage_file.HeritageFile_parse_file(self, Fname)


    @property
    def data(self):
        return self._v_data()


    def column_index(self, Col_name):
        """

        int FullPhysics::HeritageFile::column_index(const std::string &Col_name) const

        """
        return _heritage_file.HeritageFile_column_index(self, Col_name)


    def _v_data(self, *args):
        """

        blitz::Array<double, 1> FullPhysics::HeritageFile::data(const std::string &Col_name) const

        """
        return _heritage_file.HeritageFile__v_data(self, *args)


    def has_value(self, Keyword):
        """

        bool FullPhysics::HeritageFile::has_value(const std::string &Keyword) const
        Return true if we found a value for the given Keyword path. 
        """
        return _heritage_file.HeritageFile_has_value(self, Keyword)


    def value_int(self, Keyword):
        return _heritage_file.HeritageFile_value_int(self, Keyword)

    def value_double(self, Keyword):
        return _heritage_file.HeritageFile_value_double(self, Keyword)

    def value_string(self, Keyword):
        return _heritage_file.HeritageFile_value_string(self, Keyword)

    def value_bool(self, Keyword):
        return _heritage_file.HeritageFile_value_bool(self, Keyword)

    def value_string_vector(self, Keyword):
        return _heritage_file.HeritageFile_value_string_vector(self, Keyword)

    def value_double_vector(self, Keyword):
        return _heritage_file.HeritageFile_value_double_vector(self, Keyword)
    __swig_destroy__ = _heritage_file.delete_HeritageFile
    __del__ = lambda self: None
HeritageFile_swigregister = _heritage_file.HeritageFile_swigregister
HeritageFile_swigregister(HeritageFile)

# This file is compatible with both classic and new-style classes.


