# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_atmosphere_oco', [dirname(__file__)])
        except ImportError:
            import _atmosphere_oco
            return _atmosphere_oco
        if fp is not None:
            try:
                _mod = imp.load_module('_atmosphere_oco', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _atmosphere_oco = swig_import_helper()
    del swig_import_helper
else:
    import _atmosphere_oco
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_atmosphere_oco.SHARED_PTR_DISOWN_swigconstant(_atmosphere_oco)
SHARED_PTR_DISOWN = _atmosphere_oco.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.rt_atmosphere
import full_physics_swig.observer
import full_physics_swig.generic_object
import full_physics_swig.state_vector
import full_physics_swig.aerosol
class ObserverAtmosphereOco(full_physics_swig.generic_object.GenericObject):
    __swig_setmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObserverAtmosphereOco, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ObserverAtmosphereOco, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _atmosphere_oco.new_ObserverAtmosphereOco()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _atmosphere_oco.delete_ObserverAtmosphereOco
    __del__ = lambda self: None

    def notify_update(self, Observed_object):
        return _atmosphere_oco.ObserverAtmosphereOco_notify_update(self, Observed_object)

    def notify_add(self, Observed_object):
        return _atmosphere_oco.ObserverAtmosphereOco_notify_add(self, Observed_object)

    def notify_remove(self, Observed_object):
        return _atmosphere_oco.ObserverAtmosphereOco_notify_remove(self, Observed_object)
ObserverAtmosphereOco_swigregister = _atmosphere_oco.ObserverAtmosphereOco_swigregister
ObserverAtmosphereOco_swigregister(ObserverAtmosphereOco)

class AtmosphereOco(full_physics_swig.rt_atmosphere.RtAtmosphere, full_physics_swig.aerosol.ObserverAerosol):
    """

    This class maintains the atmosphere portion of the state, and uses
    this to set up the atmosphere and ground information needed to run the
    Radiative transfer code.

    This particular implementation forwards most of the work to other
    classes such as Absorber and Aerosol. This class then coordinates
    these other classes, and provides the calculations needed to set up
    the RT code.

    For some set ups, aerosol_ptr and/or ground_ptr may be null. For a
    Rayleigh only atmosphere, we don't have any aerosol to include. For up
    looking (e.g., TCCON FTS), there is no ground portion included in the
    radiative transfer.

    To speed up the calculation of the Jacobian in LIDORT, we make use of
    "intermediate" variables instead of directly using state vector
    variables. A description of this in more detail can be found in
    doc/LIDORT_Jacobian.pdf

    C++ includes: atmosphere_oco.h 
    """

    __swig_setmethods__ = {}
    for _s in [full_physics_swig.rt_atmosphere.RtAtmosphere, full_physics_swig.aerosol.ObserverAerosol]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AtmosphereOco, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.rt_atmosphere.RtAtmosphere, full_physics_swig.aerosol.ObserverAerosol]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AtmosphereOco, name)
    __repr__ = _swig_repr

    def __init__(self, absorberv, pressurev, temperaturev, aerosolv, rhv, groundv, altv, C):
        """

        FullPhysics::AtmosphereOco::AtmosphereOco(const boost::shared_ptr< Absorber > &absorberv, const
        boost::shared_ptr< Pressure > &pressurev, const boost::shared_ptr<
        Temperature > &temperaturev, const boost::shared_ptr< RelativeHumidity
        > &Rh, const std::vector< boost::shared_ptr< Altitude > > &altv, const
        boost::shared_ptr< Constant > &C)

        """
        this = _atmosphere_oco.new_AtmosphereOco(absorberv, pressurev, temperaturev, aerosolv, rhv, groundv, altv, C)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def notify_add(self, Sv):
        """

        virtual void FullPhysics::AtmosphereOco::notify_add(StateVector &Sv)

        """
        return _atmosphere_oco.AtmosphereOco_notify_add(self, Sv)


    def notify_remove(self, Sv):
        """

        virtual void FullPhysics::AtmosphereOco::notify_remove(StateVector &Sv)

        """
        return _atmosphere_oco.AtmosphereOco_notify_remove(self, Sv)


    def altitude(self, spec_index):
        """

        virtual ArrayAdWithUnit<double, 1> FullPhysics::AtmosphereOco::altitude(int spec_index) const

        """
        return _atmosphere_oco.AtmosphereOco_altitude(self, spec_index)


    def _v_number_spectrometer(self):
        """

        virtual int FullPhysics::AtmosphereOco::number_spectrometer() const

        """
        return _atmosphere_oco.AtmosphereOco__v_number_spectrometer(self)


    def _v_number_layer(self):
        """

        virtual int FullPhysics::AtmosphereOco::number_layer() const

        """
        return _atmosphere_oco.AtmosphereOco__v_number_layer(self)


    def column_optical_depth(self, wn, spec_index, Gas_name):
        """

        virtual AutoDerivative<double> FullPhysics::AtmosphereOco::column_optical_depth(double wn, int spec_index, const std::string &Gas_name) const

        """
        return _atmosphere_oco.AtmosphereOco_column_optical_depth(self, wn, spec_index, Gas_name)


    def optical_depth_wrt_iv(self, *args):
        """

        virtual ArrayAd<double, 1> FullPhysics::AtmosphereOco::optical_depth_wrt_iv(double wn, int spec_index, const ArrayAd< double, 2 > &iv) const

        """
        return _atmosphere_oco.AtmosphereOco_optical_depth_wrt_iv(self, *args)


    def single_scattering_albedo_wrt_iv(self, *args):
        """

        virtual ArrayAd<double, 1> FullPhysics::AtmosphereOco::single_scattering_albedo_wrt_iv(double wn, int spec_index, const ArrayAd< double, 2 > &iv) const

        """
        return _atmosphere_oco.AtmosphereOco_single_scattering_albedo_wrt_iv(self, *args)


    def scattering_moment_wrt_iv(self, *args):
        """

        virtual ArrayAd<double, 3> FullPhysics::AtmosphereOco::scattering_moment_wrt_iv(double wn, int spec_index, const ArrayAd< double, 2 > &iv, int
        nummom=-1, int numscat=-1) const

        """
        return _atmosphere_oco.AtmosphereOco_scattering_moment_wrt_iv(self, *args)


    def intermediate_variable(self, wn, spec_index):
        """

        virtual ArrayAd<double, 2> FullPhysics::AtmosphereOco::intermediate_variable(double wn, int spec_index) const

        """
        return _atmosphere_oco.AtmosphereOco_intermediate_variable(self, wn, spec_index)


    def _v_ground(self):
        """

        virtual const boost::shared_ptr<Ground> FullPhysics::AtmosphereOco::ground() const

        """
        return _atmosphere_oco.AtmosphereOco__v_ground(self)


    def _v_uplooking(self):
        """

        virtual bool FullPhysics::AtmosphereOco::uplooking() const

        """
        return _atmosphere_oco.AtmosphereOco__v_uplooking(self)


    def notify_update(self, *args):
        """

        virtual void FullPhysics::AtmosphereOco::notify_update(const Pressure &P)

        """
        return _atmosphere_oco.AtmosphereOco_notify_update(self, *args)


    def reset_timer(self):
        """

        virtual void FullPhysics::AtmosphereOco::reset_timer()

        """
        return _atmosphere_oco.AtmosphereOco_reset_timer(self)


    def _v_timer_info(self):
        """

        virtual std::string FullPhysics::AtmosphereOco::timer_info() const

        """
        return _atmosphere_oco.AtmosphereOco__v_timer_info(self)


    def _v_pressure(self):
        """

        const boost::shared_ptr<Pressure>& FullPhysics::AtmosphereOco::pressure_ptr() const

        """
        return _atmosphere_oco.AtmosphereOco__v_pressure(self)


    @property
    def pressure(self):
        return self._v_pressure()


    def _v_absorber(self):
        """

        const boost::shared_ptr<Absorber>& FullPhysics::AtmosphereOco::absorber_ptr() const

        """
        return _atmosphere_oco.AtmosphereOco__v_absorber(self)


    @property
    def absorber(self):
        return self._v_absorber()


    def _v_aerosol(self):
        """

        const boost::shared_ptr<Aerosol>& FullPhysics::AtmosphereOco::aerosol_ptr() const

        """
        return _atmosphere_oco.AtmosphereOco__v_aerosol(self)


    @property
    def aerosol(self):
        return self._v_aerosol()


    def set_aerosol(self, new_aerosol, Sv):
        """

        void FullPhysics::AtmosphereOco::set_aerosol(boost::shared_ptr< Aerosol > &new_aerosol, StateVector &Sv)

        """
        return _atmosphere_oco.AtmosphereOco_set_aerosol(self, new_aerosol, Sv)


    def _v_temperature(self):
        """

        const boost::shared_ptr<Temperature>& FullPhysics::AtmosphereOco::temperature_ptr() const

        """
        return _atmosphere_oco.AtmosphereOco__v_temperature(self)


    @property
    def temperature(self):
        return self._v_temperature()


    def _v_relative_humidity(self):
        """

        const boost::shared_ptr<RelativeHumidity>& FullPhysics::AtmosphereOco::relative_humidity_ptr() const

        """
        return _atmosphere_oco.AtmosphereOco__v_relative_humidity(self)


    @property
    def relative_humidity(self):
        return self._v_relative_humidity()


    def _v_constant(self):
        """

        const boost::shared_ptr<Constant>& FullPhysics::AtmosphereOco::constant_ptr() const

        """
        return _atmosphere_oco.AtmosphereOco__v_constant(self)


    @property
    def constant(self):
        return self._v_constant()


    def _v_rayleigh(self):
        """

        const boost::shared_ptr<Rayleigh>& FullPhysics::AtmosphereOco::rayleigh_ptr() const

        """
        return _atmosphere_oco.AtmosphereOco__v_rayleigh(self)


    @property
    def rayleigh(self):
        return self._v_rayleigh()


    def _v_altitude_obj(self):
        """

        const boost::shared_ptr<Altitude>& FullPhysics::AtmosphereOco::altitude_ptr(int Spec_index) const

        """
        return _atmosphere_oco.AtmosphereOco__v_altitude_obj(self)


    @property
    def altitude_obj(self):
        return self._v_altitude_obj()


    def clone(self):
        """

        boost::shared_ptr<AtmosphereOco> FullPhysics::AtmosphereOco::clone() const

        """
        return _atmosphere_oco.AtmosphereOco_clone(self)


    def _v_rayleigh_only_atmosphere(self):
        """

        bool FullPhysics::AtmosphereOco::rayleigh_only_atmosphere() const
        Indicate we have rayleigh only atmosphere, i.e., we don't have any
        aerosol content. 
        """
        return _atmosphere_oco.AtmosphereOco__v_rayleigh_only_atmosphere(self)


    @property
    def rayleigh_only_atmosphere(self):
        return self._v_rayleigh_only_atmosphere()


    def set_surface_pressure_for_testing(self, x):
        """

        void FullPhysics::AtmosphereOco::set_surface_pressure_for_testing(double x)

        """
        return _atmosphere_oco.AtmosphereOco_set_surface_pressure_for_testing(self, x)

    __swig_destroy__ = _atmosphere_oco.delete_AtmosphereOco
    __del__ = lambda self: None
AtmosphereOco_swigregister = _atmosphere_oco.AtmosphereOco_swigregister
AtmosphereOco_swigregister(AtmosphereOco)

# This file is compatible with both classic and new-style classes.


