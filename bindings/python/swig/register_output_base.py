# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_register_output_base', [dirname(__file__)])
        except ImportError:
            import _register_output_base
            return _register_output_base
        if fp is not None:
            try:
                _mod = imp.load_module('_register_output_base', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _register_output_base = swig_import_helper()
    del swig_import_helper
else:
    import _register_output_base
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _register_output_base.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _register_output_base.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _register_output_base.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _register_output_base.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _register_output_base.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _register_output_base.SwigPyIterator_equal(self, x)

    def copy(self):
        return _register_output_base.SwigPyIterator_copy(self)

    def next(self):
        return _register_output_base.SwigPyIterator_next(self)

    def __next__(self):
        return _register_output_base.SwigPyIterator___next__(self)

    def previous(self):
        return _register_output_base.SwigPyIterator_previous(self)

    def advance(self, n):
        return _register_output_base.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _register_output_base.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _register_output_base.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _register_output_base.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _register_output_base.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _register_output_base.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _register_output_base.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _register_output_base.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_register_output_base.SHARED_PTR_DISOWN_swigconstant(_register_output_base)
SHARED_PTR_DISOWN = _register_output_base.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class RegisterOutputBase(_object):
    """

    As described in the Output class, we have a decentralized model of
    producing output for L2 Full Physics.

    Rather than directly writing a value to a file, we register functions
    that can supply the values when requested. This has the advantage of
    keeping everything in sync we don't have values written out from
    earlier iterations of the algorithm.

    There isn't anything particularly special to register a function, just
    a call to Output::register_data_source. However as a matter of
    convention we collect all the functions that register data into
    classes found in the RegisterOutput directory, and derived from this
    RegisterOutputBase class. This class doesn't really give any special
    functionality, rather deriving from this class is a statement of
    intent that derived classes what to register output.

    A reasonable implementation would be to have classes that supply
    output data register there intent themselves, so for example
    Atmosphere could have register_output function. However this would
    then couple these classes with our particular output model. You could
    imagine reusing Atmosphere class in other contexts which do not want
    to use this particular output model. So again as a matter of
    convention we use a separate class to register output, in this case
    AtmosphereOutput. We may decide at some point that these extra classes
    are unnecessarily complicated design, but for now we'll keep this
    division.

    For many classes, we output different information for apriori state
    vector value vs. the final state vector value. So the registration is
    separated as two functions. Alternatively, we could have just had two
    different registration classes, but this is the way we've chosen.

    Note that by convention that we "freeze" the state of the class when
    we register the apriori_output. This allows for things like the
    StateVector to be changed after wards without changing the apriori
    state.

    C++ includes: register_output_base.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegisterOutputBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegisterOutputBase, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _register_output_base.delete_RegisterOutputBase
    __del__ = lambda self: None

    def __str__(self):
        return _register_output_base.RegisterOutputBase___str__(self)

    def desc(self):
        """

        virtual std::string FullPhysics::RegisterOutputBase::desc() const
        Description of object, to be printed to stream.

        This gives a cleaner interface for deriving from python. 
        """
        return _register_output_base.RegisterOutputBase_desc(self)


    def register_output(self, out):
        """

        virtual void FullPhysics::RegisterOutputBase::register_output(const boost::shared_ptr< Output > &out) const =0
        Register portions of class that will be written to output.

        This is for the final statevector, for classes where apriori and final
        are written out different. 
        """
        return _register_output_base.RegisterOutputBase_register_output(self, out)


    def register_output_apriori(self, out):
        """

        virtual void FullPhysics::RegisterOutputBase::register_output_apriori(const boost::shared_ptr< Output > &out) const
        Register apriori portions of class.

        The default is not to have anything written out, but derived classes
        can override this.

        Note that by convention that we "freeze" the state of the class when
        we register the apriori_output. This allows for things like the
        StateVector to be changed after wards without changing the apriori
        state. 
        """
        return _register_output_base.RegisterOutputBase_register_output_apriori(self, out)


    def __init__(self):
        if self.__class__ == RegisterOutputBase:
            _self = None
        else:
            _self = self
        this = _register_output_base.new_RegisterOutputBase(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _register_output_base.disown_RegisterOutputBase(self)
        return weakref_proxy(self)
RegisterOutputBase_swigregister = _register_output_base.RegisterOutputBase_swigregister
RegisterOutputBase_swigregister(RegisterOutputBase)

class vector_register_output(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_register_output, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_register_output, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _register_output_base.vector_register_output_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _register_output_base.vector_register_output___nonzero__(self)

    def __bool__(self):
        return _register_output_base.vector_register_output___bool__(self)

    def __len__(self):
        return _register_output_base.vector_register_output___len__(self)

    def __getslice__(self, i, j):
        return _register_output_base.vector_register_output___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _register_output_base.vector_register_output___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _register_output_base.vector_register_output___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _register_output_base.vector_register_output___delitem__(self, *args)

    def __getitem__(self, *args):
        return _register_output_base.vector_register_output___getitem__(self, *args)

    def __setitem__(self, *args):
        return _register_output_base.vector_register_output___setitem__(self, *args)

    def pop(self):
        return _register_output_base.vector_register_output_pop(self)

    def append(self, x):
        return _register_output_base.vector_register_output_append(self, x)

    def empty(self):
        return _register_output_base.vector_register_output_empty(self)

    def size(self):
        return _register_output_base.vector_register_output_size(self)

    def swap(self, v):
        return _register_output_base.vector_register_output_swap(self, v)

    def begin(self):
        return _register_output_base.vector_register_output_begin(self)

    def end(self):
        return _register_output_base.vector_register_output_end(self)

    def rbegin(self):
        return _register_output_base.vector_register_output_rbegin(self)

    def rend(self):
        return _register_output_base.vector_register_output_rend(self)

    def clear(self):
        return _register_output_base.vector_register_output_clear(self)

    def get_allocator(self):
        return _register_output_base.vector_register_output_get_allocator(self)

    def pop_back(self):
        return _register_output_base.vector_register_output_pop_back(self)

    def erase(self, *args):
        return _register_output_base.vector_register_output_erase(self, *args)

    def __init__(self, *args):
        this = _register_output_base.new_vector_register_output(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _register_output_base.vector_register_output_push_back(self, x)

    def front(self):
        return _register_output_base.vector_register_output_front(self)

    def back(self):
        return _register_output_base.vector_register_output_back(self)

    def assign(self, n, x):
        return _register_output_base.vector_register_output_assign(self, n, x)

    def resize(self, *args):
        return _register_output_base.vector_register_output_resize(self, *args)

    def insert(self, *args):
        return _register_output_base.vector_register_output_insert(self, *args)

    def reserve(self, n):
        return _register_output_base.vector_register_output_reserve(self, n)

    def capacity(self):
        return _register_output_base.vector_register_output_capacity(self)
    __swig_destroy__ = _register_output_base.delete_vector_register_output
    __del__ = lambda self: None
vector_register_output_swigregister = _register_output_base.vector_register_output_swigregister
vector_register_output_swigregister(vector_register_output)

# This file is compatible with both classic and new-style classes.


