# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_luabind_object', [dirname(__file__)])
        except ImportError:
            import _luabind_object
            return _luabind_object
        if fp is not None:
            try:
                _mod = imp.load_module('_luabind_object', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _luabind_object = swig_import_helper()
    del swig_import_helper
else:
    import _luabind_object
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_luabind_object.SHARED_PTR_DISOWN_swigconstant(_luabind_object)
SHARED_PTR_DISOWN = _luabind_object.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.state_vector
class LuaCallback(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LuaCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LuaCallback, name)
    __repr__ = _swig_repr

    def __init__(self, Ls):
        if self.__class__ == LuaCallback:
            _self = None
        else:
            _self = self
        this = _luabind_object.new_LuaCallback(_self, Ls)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _luabind_object.delete_LuaCallback
    __del__ = lambda self: None

    def call(self, Obj1, Obj2, Obj3, Obj4, Obj5, Obj6, Obj7, Obj8, Obj9, Obj10):
        return _luabind_object.LuaCallback_call(self, Obj1, Obj2, Obj3, Obj4, Obj5, Obj6, Obj7, Obj8, Obj9, Obj10)

    def __str__(self):
        return _luabind_object.LuaCallback___str__(self)
    def __disown__(self):
        self.this.disown()
        _luabind_object.disown_LuaCallback(self)
        return weakref_proxy(self)
LuaCallback_swigregister = _luabind_object.LuaCallback_swigregister
LuaCallback_swigregister(LuaCallback)


class LuaCallbackWrap(LuaCallback):
    def __init__(self,ls,f):
       LuaCallback.__init__(self, ls)
       self.ls = ls
       self.f = f
       t = inspect.getargspec(f)[0]
       self.narg = len(t)
       if(self.narg > 0 and t[0] == 'self'):
         self.narg = self.narg - 1
       if(self.narg > 10):
         raise "We only support up to 10 argument in a function. This limitation comes from luabind"

    def call(self,obj1, obj2, obj3, obj4, obj5, obj6, obj7, obj8, obj9,
             obj10):
       if(self.narg == 0):
         t = self.f()
       elif(self.narg == 1):
         t = self.f(obj1.cast_type())
       elif(self.narg == 2):
         t = self.f(obj1.cast_type(), obj2.cast_type())
       elif(self.narg == 3):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type())
       elif(self.narg == 4):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type())
       elif(self.narg == 5):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type())
       elif(self.narg == 6):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), oj6.cast_type())
       elif(self.narg == 7):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), obj6.cast_type(),
                    obj7.cast_type())
       elif(self.narg == 8):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), obj6.cast_type(),
                    obj7.cast_type(), obj8.cast_type())
       elif(self.narg == 9):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), obj6.cast_type(),
                    obj7.cast_type(), obj8.cast_type(), obj9.cast_type())
       elif(self.narg == 10):
         t = self.f(obj1.cast_type(), obj2.cast_type(), obj3.cast_type(),
                    obj4.cast_type(), obj5.cast_type(), obj6.cast_type(),
                    obj7.cast_type(), obj8.cast_type(), obj9.cast_type().
                    obj10.cast_type())
       else:
         raise "This shouldn't be able to happen"

       if(t == None):
           return LuabindObject.nil(self.ls)

       elif(isinstance(t, dict)):
           new_table = LuabindObject.nil(self.ls).new_table()
           for t_key, t_val in t.items():
              new_table[t_key] = t_val
           return LuabindObject(self.ls, new_table)

       elif(isinstance(t, list) or isinstance(t, tuple)):
           new_table = LuabindObject.nil(self.ls).new_table()
           for t_idx, t_val in enumerate(t):
               new_table[t_idx+1] = t_val
           return LuabindObject(self.ls, new_table)

       else:
         return LuabindObject(self.ls, t)


import inspect

class LuabindIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LuabindIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LuabindIterator, name)
    __repr__ = _swig_repr

    def __init__(self, Lbo, Ls):
        this = _luabind_object.new_LuabindIterator(Lbo, Ls)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def at_end(self):
        return _luabind_object.LuabindIterator_at_end(self)

    def key(self):
        return _luabind_object.LuabindIterator_key(self)

    def next(self):
        return _luabind_object.LuabindIterator_next(self)
    __swig_destroy__ = _luabind_object.delete_LuabindIterator
    __del__ = lambda self: None
LuabindIterator_swigregister = _luabind_object.LuabindIterator_swigregister
LuabindIterator_swigregister(LuabindIterator)

class LuabindObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LuabindObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LuabindObject, name)
    __repr__ = _swig_repr

    def __str__(self):
        return _luabind_object.LuabindObject___str__(self)

    def is_nil(self):
        return _luabind_object.LuabindObject_is_nil(self)

    def is_boolean(self):
        return _luabind_object.LuabindObject_is_boolean(self)

    def is_number(self):
        return _luabind_object.LuabindObject_is_number(self)

    def is_string(self):
        return _luabind_object.LuabindObject_is_string(self)

    def is_table(self):
        return _luabind_object.LuabindObject_is_table(self)

    def is_function(self):
        return _luabind_object.LuabindObject_is_function(self)

    def length(self, index=0):
        return _luabind_object.LuabindObject_length(self, index)

    def call(self, *args):
        return _luabind_object.LuabindObject_call(self, *args)

    def lua_state(self):
        return _luabind_object.LuabindObject_lua_state(self)

    def object(self):
        return _luabind_object.LuabindObject_object(self)

    def new_table(self):
        return _luabind_object.LuabindObject_new_table(self)
    __swig_getmethods__["nil"] = lambda x: _luabind_object.LuabindObject_nil
    if _newclass:
        nil = staticmethod(_luabind_object.LuabindObject_nil)

    def value_generic_object(self):
        return _luabind_object.LuabindObject_value_generic_object(self)

    def isvector_altitude(self):
        return _luabind_object.LuabindObject_isvector_altitude(self)

    def getvector_altitude(self):
        return _luabind_object.LuabindObject_getvector_altitude(self)

    def isblitzarray1d_double(self):
        return _luabind_object.LuabindObject_isblitzarray1d_double(self)

    def getblitzarray1d_double(self):
        return _luabind_object.LuabindObject_getblitzarray1d_double(self)

    def isblitzarray2d_double(self):
        return _luabind_object.LuabindObject_isblitzarray2d_double(self)

    def getblitzarray2d_double(self):
        return _luabind_object.LuabindObject_getblitzarray2d_double(self)

    def isblitzarray1d_bool(self):
        return _luabind_object.LuabindObject_isblitzarray1d_bool(self)

    def getblitzarray1d_bool(self):
        return _luabind_object.LuabindObject_getblitzarray1d_bool(self)

    def set_value(self, *args):
        return _luabind_object.LuabindObject_set_value(self, *args)

    def set_index(self, *args):
        return _luabind_object.LuabindObject_set_index(self, *args)

    def __init__(self, *args):
        this = _luabind_object.new_LuabindObject(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def set_value_bool(self, Vname, V):
        return _luabind_object.LuabindObject_set_value_bool(self, Vname, V)

    def set_index_bool(self, Vidx, V):
        return _luabind_object.LuabindObject_set_index_bool(self, Vidx, V)

    def get_string(self, Vname):
        return _luabind_object.LuabindObject_get_string(self, Vname)

    def get_index(self, Vidx):
        return _luabind_object.LuabindObject_get_index(self, Vidx)

    def getbool(self):
        return _luabind_object.LuabindObject_getbool(self)

    def getnum(self):
        return _luabind_object.LuabindObject_getnum(self)

    def getstring(self):
        return _luabind_object.LuabindObject_getstring(self)

    def cast_type(self):
        '''Cast to underlying type'''
        t = "Types"
        if(self.is_nil()):
            return None
        v = self.value_generic_object()
        if(v is not None):
            return v
        elif(self.is_boolean()):
            return self.getbool()
        elif(self.is_number()):
            return self.getnum()
        elif(self.is_string()):
            return self.getstring()
        elif(self.is_table()):
            return self
        elif(self.is_function()):
            return self
        elif(self.isblitzarray1d_double()):
            return self.getblitzarray1d_double()
        elif(self.isblitzarray2d_double()):
            return self.getblitzarray2d_double()
        elif(self.isblitzarray1d_bool()):
            return self.getblitzarray1d_bool()
        elif(self.isvector_altitude()):
            return self.getvector_altitude()
        return self

    def __getitem__(self, key):
        if isinstance(key, int):
            return self.get_index(key).cast_type()
        else:
            return self.get_string(key).cast_type()

    def __setitem__(self, key, v):
    # Set up which set method to use
        if(isinstance(key, int)):
            if key <= 0:
                raise ValueError("Lua integer indexing is 1 based, not 0 based")
            set_method = self.set_index
        else:
            set_method = self.set_value

    # Perform any value specific work
        if(not isinstance(v, LuabindObject) and hasattr(v, '__call__')):
            set_method(key, LuaCallbackWrap(self.lua_state(), v))

        elif(isinstance(v, bool)):
            if(isinstance(key, int)):
                set_method = self.set_index_bool
            else:
                set_method = self.set_value_bool
            set_method(key, v)

        elif(isinstance(v, dict)):
            new_table = self.new_table()
            for v_key, v_val in v.items():
               new_table[v_key] = v_val
            set_method(key, new_table)

        elif(isinstance(v, list) or isinstance(v, tuple)):
    # Only support assigining lists or tuples for now,
    # since so many other objects are iterable but
    # need to be set differently, for instance LuabindObject
    # itself is iterable
            new_table = self.new_table()
            for v_idx, v_val in enumerate(v):
               new_table[v_idx+1] = v_val
            set_method(key, new_table)
        else:
            set_method(key, v)

    def __getattr__(self, key):
        return self[key]

    def __setattr__(self, key, v):
        if(key == "this"):
            self.__dict__[key] = v
        else:
            self[key] = v



    def __call__(self, *args):
        luargs = []
        luargs2 = []
        for a in args:
            if(isinstance(a, LuabindObject)):
               t = a
            else:
               t = LuabindObject(self.lua_state(), a)
            luargs.append(t)
            luargs2.append(t.object())
        return self.call(*luargs2).cast_type()

    def __len__(self):
        return self.cast_type().length()

    def __iter__(self):
        if(self.is_table()):
            def luabind_gen():
                lb_iter = LuabindIterator(self, self.lua_state())
                while not lb_iter.at_end():
                    yield lb_iter.next().cast_type()
            return luabind_gen()
        else:
            raise TypeError("Can not iterate on non table LuabindObject")

    def __dir__(self):
        if(self.is_table()):
            obj_contents = []
            lb_iter = LuabindIterator(self, self.lua_state())
            while not lb_iter.at_end():
                key_item = lb_iter.key().cast_type()
    # Only add strings to dir() listing,
    # because in Lua arrays would have numeric
    # keys and these are not accessible through
    # getattr
                if isinstance(key_item, str):
                    obj_contents.append( key_item  )
                lb_iter.next()
            return obj_contents
        else:
            item = self.cast_type()
    # Try not to engage in infinite recursion!
            if isinstance(item, LuabindObject):
                return []
            else:
                return dir(item)

    __swig_destroy__ = _luabind_object.delete_LuabindObject
    __del__ = lambda self: None
LuabindObject_swigregister = _luabind_object.LuabindObject_swigregister
LuabindObject_swigregister(LuabindObject)

def LuabindObject_nil(Ls):
    return _luabind_object.LuabindObject_nil(Ls)
LuabindObject_nil = _luabind_object.LuabindObject_nil

# This file is compatible with both classic and new-style classes.


