# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_state_vector', [dirname(__file__)])
        except ImportError:
            import _state_vector
            return _state_vector
        if fp is not None:
            try:
                _mod = imp.load_module('_state_vector', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _state_vector = swig_import_helper()
    del swig_import_helper
else:
    import _state_vector
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_state_vector.SHARED_PTR_DISOWN_swigconstant(_state_vector)
SHARED_PTR_DISOWN = _state_vector.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.generic_object
class ObserverStateVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObserverStateVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ObserverStateVector, name)
    __repr__ = _swig_repr

    def notify_add(self, Obs):
        return _state_vector.ObserverStateVector_notify_add(self, Obs)

    def notify_remove(self, Obs):
        return _state_vector.ObserverStateVector_notify_remove(self, Obs)

    def notify_update(self, Obs):
        return _state_vector.ObserverStateVector_notify_update(self, Obs)

    def __init__(self):
        if self.__class__ == ObserverStateVector:
            _self = None
        else:
            _self = self
        this = _state_vector.new_ObserverStateVector(_self, )
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _state_vector.disown_ObserverStateVector(self)
        return weakref_proxy(self)
ObserverStateVector_swigregister = _state_vector.ObserverStateVector_swigregister
ObserverStateVector_swigregister(ObserverStateVector)

class ObservableStateVector(full_physics_swig.generic_object.GenericObject):
    __swig_setmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObservableStateVector, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ObservableStateVector, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _state_vector.delete_ObservableStateVector
    __del__ = lambda self: None

    def add_observer_and_keep_reference(self, Obs):
        return _state_vector.ObservableStateVector_add_observer_and_keep_reference(self, Obs)

    def add_observer(self, Obs):
        return _state_vector.ObservableStateVector_add_observer(self, Obs)

    def remove_observer(self, Obs):
        return _state_vector.ObservableStateVector_remove_observer(self, Obs)
ObservableStateVector_swigregister = _state_vector.ObservableStateVector_swigregister
ObservableStateVector_swigregister(ObservableStateVector)

class StateVectorObserver(ObserverStateVector):
    """

    This is an observer of a StateVector.

    If attached to a StateVector, this class gets notified when a state
    vector is updated.

    It is completely unspecified what an observer does with this
    information, but commonly the class will update its internal state
    based on the state vector update.

    C++ includes: state_vector.h 
    """

    __swig_setmethods__ = {}
    for _s in [ObserverStateVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StateVectorObserver, name, value)
    __swig_getmethods__ = {}
    for _s in [ObserverStateVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StateVectorObserver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _state_vector.delete_StateVectorObserver
    __del__ = lambda self: None

    def __str__(self):
        return _state_vector.StateVectorObserver___str__(self)

    def mark_used(self, Sv, Used):
        """

        virtual void FullPhysics::StateVectorObserver::mark_used(const StateVector &Sv, blitz::Array< bool, 1 > &Used) const
        Mark elements that we are actively using (i.e., that aren't ignored).

        You only need to mark the ones that are used as true, everything is
        already initialized as false. Default is to do nothing. 
        """
        return _state_vector.StateVectorObserver_mark_used(self, Sv, Used)


    def state_vector_name(self, Sv, Sv_name):
        """

        virtual void FullPhysics::StateVectorObserver::state_vector_name(const StateVector &Sv, blitz::Array< std::string, 1 > &Sv_name) const
        Update any portion of the list of the state vector names that apply to
        this object.

        Default is to do nothing. 
        """
        return _state_vector.StateVectorObserver_state_vector_name(self, Sv, Sv_name)

StateVectorObserver_swigregister = _state_vector.StateVectorObserver_swigregister
StateVectorObserver_swigregister(StateVectorObserver)

class StateVector(ObservableStateVector):
    """

    This handles informing a set of interested objects when the state
    vector has updated.

    Those objects then update their internal state to account for the new
    state vector.

    C++ includes: state_vector.h 
    """

    __swig_setmethods__ = {}
    for _s in [ObservableStateVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StateVector, name, value)
    __swig_getmethods__ = {}
    for _s in [ObservableStateVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StateVector, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _state_vector.delete_StateVector
    __del__ = lambda self: None

    def __str__(self):
        return _state_vector.StateVector___str__(self)

    def __init__(self):
        """

        FullPhysics::StateVector::StateVector()

        """
        this = _state_vector.new_StateVector()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add_observer(self, Obs):
        """

        virtual void FullPhysics::StateVector::add_observer(Observer< StateVector > &Obs)

        """
        return _state_vector.StateVector_add_observer(self, Obs)


    def remove_observer(self, Obs):
        """

        virtual void FullPhysics::StateVector::remove_observer(Observer< StateVector > &Obs)

        """
        return _state_vector.StateVector_remove_observer(self, Obs)


    def _v_state(self):
        """

        const blitz::Array<double, 1>& FullPhysics::StateVector::state() const
        Current state vector. 
        """
        return _state_vector.StateVector__v_state(self)


    @property
    def state(self):
        return self._v_state()


    def _v_state_with_derivative(self):
        """

        const ArrayAd<double, 1>& FullPhysics::StateVector::state_with_derivative() const
        Return the state vector as state() does, but also make each value a
        AutoDerivative.

        The derivative is with respect to the state vector, i.e., we treat the
        state vector as the independent variables. This means the first value
        has a gradient all 0's except for 1 in the first index, the second
        value all zeros except for 1 in the second index, etc. 
        """
        return _state_vector.StateVector__v_state_with_derivative(self)


    @property
    def state_with_derivative(self):
        return self._v_state_with_derivative()


    def _state_vector_name(self):
        return _state_vector.StateVector__state_vector_name(self)

    @property
    def state_vector_name(self):
        return self._state_vector_name()


    def _v_state_covariance(self):
        """

        const blitz::Array<double, 2>& FullPhysics::StateVector::state_covariance() const
        Current covariance of the state vector. 
        """
        return _state_vector.StateVector__v_state_covariance(self)


    @property
    def state_covariance(self):
        return self._v_state_covariance()


    def update_state(self, *args):
        """

        void FullPhysics::StateVector::update_state(const blitz::Array< double, 1 > &X, const blitz::Array< double, 2 >
        &Cov)

        """
        return _state_vector.StateVector_update_state(self, *args)


    def _v_used_flag(self):
        """

        blitz::Array<bool, 1> FullPhysics::StateVector::used_flag() const

        """
        return _state_vector.StateVector__v_used_flag(self)


    @property
    def used_flag(self):
        return self._v_used_flag()


    def _v_observer_claimed_size(self, *args):
        """

        void FullPhysics::StateVector::observer_claimed_size(int Pstart)
        Update claimed size of state vector. 
        """
        return _state_vector.StateVector__v_observer_claimed_size(self, *args)


    @property
    def observer_claimed_size(self):
        return self._v_observer_claimed_size()

    @observer_claimed_size.setter
    def observer_claimed_size(self, value):
      self._v_observer_claimed_size(value)

StateVector_swigregister = _state_vector.StateVector_swigregister
StateVector_swigregister(StateVector)

class SubStateVectorObserver(StateVectorObserver):
    """

    A common StateVectorObserver just "owns" a subset of the
    StateVector.

    This class gives the common behavior for this case.

    C++ includes: state_vector.h 
    """

    __swig_setmethods__ = {}
    for _s in [StateVectorObserver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubStateVectorObserver, name, value)
    __swig_getmethods__ = {}
    for _s in [StateVectorObserver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SubStateVectorObserver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _state_vector.delete_SubStateVectorObserver
    __del__ = lambda self: None

    def notify_update(self, Sv):
        """

        virtual void FullPhysics::SubStateVectorObserver::notify_update(const StateVector &Sv)

        """
        return _state_vector.SubStateVectorObserver_notify_update(self, Sv)


    def mark_used(self, Sv, Used):
        """

        virtual void FullPhysics::SubStateVectorObserver::mark_used(const StateVector &Sv, blitz::Array< bool, 1 > &Used) const
        Mark elements that we are actively using (i.e., that aren't ignored).

        You only need to mark the ones that are used as true, everything is
        already initialized as false. Default is to do nothing. 
        """
        return _state_vector.SubStateVectorObserver_mark_used(self, Sv, Used)


    def state_vector_name(self, Sv, Sv_name):
        """

        virtual void FullPhysics::SubStateVectorObserver::state_vector_name(const StateVector &Sv, blitz::Array< std::string, 1 > &Sv_name) const
        Update any portion of the list of the state vector names that apply to
        this object.

        Default is to do nothing. 
        """
        return _state_vector.SubStateVectorObserver_state_vector_name(self, Sv, Sv_name)


    def _v_state_vector_start_index(self):
        """

        int FullPhysics::SubStateVectorObserver::state_vector_start_index() const
        Starting index of state vector used by this object. 
        """
        return _state_vector.SubStateVectorObserver__v_state_vector_start_index(self)


    @property
    def state_vector_start_index(self):
        return self._v_state_vector_start_index()


    def _v_sub_vector_size(self):
        """

        int FullPhysics::SubStateVectorObserver::sub_vector_size() const
        Length of the sub set of the state vector used by this object. 
        """
        return _state_vector.SubStateVectorObserver__v_sub_vector_size(self)


    @property
    def sub_vector_size(self):
        return self._v_sub_vector_size()


    def update_sub_state(self, Sv_sub, Cov_sub):
        """

        virtual void FullPhysics::SubStateVectorObserver::update_sub_state(const ArrayAd< double, 1 > &Sv_sub, const blitz::Array< double, 2 >
        &Cov_sub)=0
        Called by update_state with the subset of the state vector used by
        this class. 
        """
        return _state_vector.SubStateVectorObserver_update_sub_state(self, Sv_sub, Cov_sub)


    def mark_used_sub(self, Used):
        """

        virtual void FullPhysics::SubStateVectorObserver::mark_used_sub(blitz::Array< bool, 1 > &Used) const
        Called by mark_used with the subset of the state vector used by this
        class.

        The default marks everything as used, but derived classes can override
        this. 
        """
        return _state_vector.SubStateVectorObserver_mark_used_sub(self, Used)


    def state_vector_name_sub(self, Sv_name):
        """

        virtual void FullPhysics::SubStateVectorObserver::state_vector_name_sub(blitz::Array< std::string, 1 > &Sv_name) const
        Called by state_vector_name with the subset of the Sv_name used by
        this class.

        The default function doesn't change anything, but derived classes can
        ovveride this. 
        """
        return _state_vector.SubStateVectorObserver_state_vector_name_sub(self, Sv_name)


    def print_desc(self, Os):
        """

        virtual void FullPhysics::SubStateVectorObserver::print(std::ostream &Os) const

        """
        return _state_vector.SubStateVectorObserver_print_desc(self, Os)


    def notify_add(self, Sv):
        """

        virtual void FullPhysics::SubStateVectorObserver::notify_add(StateVector &Sv)

        """
        return _state_vector.SubStateVectorObserver_notify_add(self, Sv)


    def notify_remove(self, Sv):
        """

        virtual void FullPhysics::SubStateVectorObserver::notify_remove(StateVector &Sv)

        """
        return _state_vector.SubStateVectorObserver_notify_remove(self, Sv)

SubStateVectorObserver_swigregister = _state_vector.SubStateVectorObserver_swigregister
SubStateVectorObserver_swigregister(SubStateVectorObserver)

# This file is compatible with both classic and new-style classes.


