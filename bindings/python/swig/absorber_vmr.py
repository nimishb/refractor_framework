# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_absorber_vmr', [dirname(__file__)])
        except ImportError:
            import _absorber_vmr
            return _absorber_vmr
        if fp is not None:
            try:
                _mod = imp.load_module('_absorber_vmr', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _absorber_vmr = swig_import_helper()
    del swig_import_helper
else:
    import _absorber_vmr
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _absorber_vmr.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _absorber_vmr.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _absorber_vmr.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _absorber_vmr.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _absorber_vmr.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _absorber_vmr.SwigPyIterator_equal(self, x)

    def copy(self):
        return _absorber_vmr.SwigPyIterator_copy(self)

    def next(self):
        return _absorber_vmr.SwigPyIterator_next(self)

    def __next__(self):
        return _absorber_vmr.SwigPyIterator___next__(self)

    def previous(self):
        return _absorber_vmr.SwigPyIterator_previous(self)

    def advance(self, n):
        return _absorber_vmr.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _absorber_vmr.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _absorber_vmr.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _absorber_vmr.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _absorber_vmr.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _absorber_vmr.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _absorber_vmr.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _absorber_vmr.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_absorber_vmr.SHARED_PTR_DISOWN_swigconstant(_absorber_vmr)
SHARED_PTR_DISOWN = _absorber_vmr.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.state_vector
import full_physics_swig.generic_object
class ObservableAbsorberVmr(full_physics_swig.generic_object.GenericObject):
    __swig_setmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObservableAbsorberVmr, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ObservableAbsorberVmr, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _absorber_vmr.delete_ObservableAbsorberVmr
    __del__ = lambda self: None

    def add_observer_and_keep_reference(self, Obs):
        return _absorber_vmr.ObservableAbsorberVmr_add_observer_and_keep_reference(self, Obs)

    def add_observer(self, Obs):
        return _absorber_vmr.ObservableAbsorberVmr_add_observer(self, Obs)

    def remove_observer(self, Obs):
        return _absorber_vmr.ObservableAbsorberVmr_remove_observer(self, Obs)
ObservableAbsorberVmr_swigregister = _absorber_vmr.ObservableAbsorberVmr_swigregister
ObservableAbsorberVmr_swigregister(ObservableAbsorberVmr)

class ObserverAbsorberVmr(full_physics_swig.generic_object.GenericObject):
    __swig_setmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObserverAbsorberVmr, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.generic_object.GenericObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ObserverAbsorberVmr, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _absorber_vmr.new_ObserverAbsorberVmr()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _absorber_vmr.delete_ObserverAbsorberVmr
    __del__ = lambda self: None

    def notify_update(self, Observed_object):
        return _absorber_vmr.ObserverAbsorberVmr_notify_update(self, Observed_object)

    def notify_add(self, Observed_object):
        return _absorber_vmr.ObserverAbsorberVmr_notify_add(self, Observed_object)

    def notify_remove(self, Observed_object):
        return _absorber_vmr.ObserverAbsorberVmr_notify_remove(self, Observed_object)
ObserverAbsorberVmr_swigregister = _absorber_vmr.ObserverAbsorberVmr_swigregister
ObserverAbsorberVmr_swigregister(ObserverAbsorberVmr)

class AbsorberVmr(full_physics_swig.state_vector.StateVectorObserver, ObservableAbsorberVmr):
    """

    This gives the Gas Absorber Volumn mixing ratio for a single gas.

    This gets used by AbsorberAbsco class.

    When implementing a new class, you almost always will want to derive
    from AbsorberVmrImpBase rather than from this class. See that class
    for a description.

    C++ includes: absorber_vmr.h 
    """

    __swig_setmethods__ = {}
    for _s in [full_physics_swig.state_vector.StateVectorObserver, ObservableAbsorberVmr]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbsorberVmr, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.state_vector.StateVectorObserver, ObservableAbsorberVmr]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AbsorberVmr, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _absorber_vmr.delete_AbsorberVmr
    __del__ = lambda self: None

    def add_observer(self, Obs):
        """

        virtual void FullPhysics::AbsorberVmr::add_observer(Observer< AbsorberVmr > &Obs)

        """
        return _absorber_vmr.AbsorberVmr_add_observer(self, Obs)


    def remove_observer(self, Obs):
        """

        virtual void FullPhysics::AbsorberVmr::remove_observer(Observer< AbsorberVmr > &Obs)

        """
        return _absorber_vmr.AbsorberVmr_remove_observer(self, Obs)


    def clone(self, *args):
        """

        virtual boost::shared_ptr<AbsorberVmr> FullPhysics::AbsorberVmr::clone(const boost::shared_ptr< Pressure > &Press) const =0
        This version of clone takes a pressure to use.

        The intent is that the pressure has been cloned from the original
        pressure (although this class has no way to verify this). This allows
        sets of objects to be cloned using a common Pressure clone, e.g.
        Atmosphere. 
        """
        return _absorber_vmr.AbsorberVmr_clone(self, *args)


    def _v_gas_name(self):
        """

        virtual std::string FullPhysics::AbsorberVmr::gas_name() const =0
        This indicates the name of this particular Absorber.

        The naming convention is free form but recommended to use the short
        form often used by HITRAN 
        """
        return _absorber_vmr.AbsorberVmr__v_gas_name(self)


    @property
    def gas_name(self):
        return self._v_gas_name()


    def volume_mixing_ratio(self, P):
        """

        virtual AutoDerivative<double> FullPhysics::AbsorberVmr::volume_mixing_ratio(const AutoDerivative< double > &P) const =0
        This returns the volume mixing ratio at the given pressure level.

        This is dimensionless, and the pressure is in Pascals 
        """
        return _absorber_vmr.AbsorberVmr_volume_mixing_ratio(self, P)


    def vmr_grid(self, P):
        """

        virtual ArrayAd<double, 1> FullPhysics::AbsorberVmr::vmr_grid(const Pressure &P) const

        """
        return _absorber_vmr.AbsorberVmr_vmr_grid(self, P)


    def _v_state_used(self):
        """

        virtual blitz::Array<bool, 1> FullPhysics::AbsorberVmr::state_used() const =0
        Indicate what portion of the state vector is used to calculate the
        VMR. 
        """
        return _absorber_vmr.AbsorberVmr__v_state_used(self)


    @property
    def state_used(self):
        return self._v_state_used()


    def __str__(self):
        return _absorber_vmr.AbsorberVmr___str__(self)
AbsorberVmr_swigregister = _absorber_vmr.AbsorberVmr_swigregister
AbsorberVmr_swigregister(AbsorberVmr)

class vector_absorber_vmr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_absorber_vmr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_absorber_vmr, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _absorber_vmr.vector_absorber_vmr_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _absorber_vmr.vector_absorber_vmr___nonzero__(self)

    def __bool__(self):
        return _absorber_vmr.vector_absorber_vmr___bool__(self)

    def __len__(self):
        return _absorber_vmr.vector_absorber_vmr___len__(self)

    def __getslice__(self, i, j):
        return _absorber_vmr.vector_absorber_vmr___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _absorber_vmr.vector_absorber_vmr___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _absorber_vmr.vector_absorber_vmr___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _absorber_vmr.vector_absorber_vmr___delitem__(self, *args)

    def __getitem__(self, *args):
        return _absorber_vmr.vector_absorber_vmr___getitem__(self, *args)

    def __setitem__(self, *args):
        return _absorber_vmr.vector_absorber_vmr___setitem__(self, *args)

    def pop(self):
        return _absorber_vmr.vector_absorber_vmr_pop(self)

    def append(self, x):
        return _absorber_vmr.vector_absorber_vmr_append(self, x)

    def empty(self):
        return _absorber_vmr.vector_absorber_vmr_empty(self)

    def size(self):
        return _absorber_vmr.vector_absorber_vmr_size(self)

    def swap(self, v):
        return _absorber_vmr.vector_absorber_vmr_swap(self, v)

    def begin(self):
        return _absorber_vmr.vector_absorber_vmr_begin(self)

    def end(self):
        return _absorber_vmr.vector_absorber_vmr_end(self)

    def rbegin(self):
        return _absorber_vmr.vector_absorber_vmr_rbegin(self)

    def rend(self):
        return _absorber_vmr.vector_absorber_vmr_rend(self)

    def clear(self):
        return _absorber_vmr.vector_absorber_vmr_clear(self)

    def get_allocator(self):
        return _absorber_vmr.vector_absorber_vmr_get_allocator(self)

    def pop_back(self):
        return _absorber_vmr.vector_absorber_vmr_pop_back(self)

    def erase(self, *args):
        return _absorber_vmr.vector_absorber_vmr_erase(self, *args)

    def __init__(self, *args):
        this = _absorber_vmr.new_vector_absorber_vmr(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _absorber_vmr.vector_absorber_vmr_push_back(self, x)

    def front(self):
        return _absorber_vmr.vector_absorber_vmr_front(self)

    def back(self):
        return _absorber_vmr.vector_absorber_vmr_back(self)

    def assign(self, n, x):
        return _absorber_vmr.vector_absorber_vmr_assign(self, n, x)

    def resize(self, *args):
        return _absorber_vmr.vector_absorber_vmr_resize(self, *args)

    def insert(self, *args):
        return _absorber_vmr.vector_absorber_vmr_insert(self, *args)

    def reserve(self, n):
        return _absorber_vmr.vector_absorber_vmr_reserve(self, n)

    def capacity(self):
        return _absorber_vmr.vector_absorber_vmr_capacity(self)
    __swig_destroy__ = _absorber_vmr.delete_vector_absorber_vmr
    __del__ = lambda self: None
vector_absorber_vmr_swigregister = _absorber_vmr.vector_absorber_vmr_swigregister
vector_absorber_vmr_swigregister(vector_absorber_vmr)

# This file is compatible with both classic and new-style classes.


