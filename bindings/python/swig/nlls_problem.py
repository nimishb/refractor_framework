# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_nlls_problem', [dirname(__file__)])
        except ImportError:
            import _nlls_problem
            return _nlls_problem
        if fp is not None:
            try:
                _mod = imp.load_module('_nlls_problem', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _nlls_problem = swig_import_helper()
    del swig_import_helper
else:
    import _nlls_problem
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except Exception:
    weakref_proxy = lambda x: x



_nlls_problem.SHARED_PTR_DISOWN_swigconstant(_nlls_problem)
SHARED_PTR_DISOWN = _nlls_problem.SHARED_PTR_DISOWN

def _new_from_init(cls, version, *args):
    '''For use with pickle, covers common case where we just store the
    arguments needed to create an object. See for example HdfFile'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__(*args)
    return inst

def _new_from_set(cls, version, *args):
    '''For use with pickle, covers common case where we use a set function 
    to assign the value'''
    if(cls.pickle_format_version() != version):
      raise RuntimeException("Class is expecting a pickled object with version number %d, but we found %d" % (cls.pickle_format_version(), version))
    inst = cls.__new__(cls)
    inst.__init__()
    inst.set(*args)
    return inst

import full_physics_swig.cost_func_diff
import full_physics_swig.cost_func
import full_physics_swig.problem_state
import full_physics_swig.generic_object
class NLLSProblem(full_physics_swig.cost_func_diff.CostFuncDiff):
    """

    The base class for the Non-Linear Least Squares problem.

    The class NLLSProblem is the base class for all problem classes that
    implement a Non-Linear Least Squares (NLLS) problem. The two main
    interface components provided by this class are the residual of the
    problem (a vector function)

    the Jacobian of the residual (the first order derivatives and a matrix
    function)

    A NLLS problem can be solved by NLLS solvers such as the Gauss-Newton
    or the Levenberg-Marquardt methods.

    NLLSProblem implements cost and gradient from its inherited classes;
    therefore, an NLLS problem can also be solved by methods that solve
    optimization problems of CostFunc or CostFuncDiff form.

    A DESIGN RELATED QUESTION:

    Similar to CostFunc and CostFuncDiff, why don't we have a class that
    only adds the residual to the class interface and then derive this
    class from that one to add the Jacobian to the interface as well?

    ANSWER TO THE ABOVE QUESTION:

    As mentioned in the comments of CostFunc, CostFuncDiff and NLLSProblem
    (this) classes, the problems of the forms cost only (CostFunc)

    cost and gradient (CostFuncDiff)

    residual and Jacobian ( NLLSProblem)

    can be solved by certain algorithms. However, there is no method for
    solving a problem of the form residual only

    If the first order derivatives (the Jacobian) of the residual are not
    available, then the problem can be solved only by the methods that
    solve a problem of cost-only (CostFunc) form after converting the
    residual vector function into a cost scalar function using the
    equation \\[ c(x) = \\frac{1}{2}\\parallel f(x) \\parallel^2
    \\]

    C++ includes: nlls_problem.h 
    """

    __swig_setmethods__ = {}
    for _s in [full_physics_swig.cost_func_diff.CostFuncDiff]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NLLSProblem, name, value)
    __swig_getmethods__ = {}
    for _s in [full_physics_swig.cost_func_diff.CostFuncDiff]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NLLSProblem, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _nlls_problem.delete_NLLSProblem
    __del__ = lambda self: None

    def _v_cost(self):
        """

        virtual double FullPhysics::NLLSProblem::cost()
        Read comments on CostFunc::cost() 
        """
        return _nlls_problem.NLLSProblem__v_cost(self)


    @property
    def cost(self):
        return self._v_cost()


    def _v_residual(self):
        """

        virtual blitz::Array<double, 1> FullPhysics::NLLSProblem::residual()=0
        The residual vector function.

        This method must be implemented by the classes derived from this
        class.

        The parameters (the point in the parameter space) must have already
        been set before calling this method. The parameters are already set if
        one of the following methods is already called successfully:
        parameters() (see ProblemState class)

        cost_x() (see CostFunc class)

        gradient_x() (see CostFuncDiff class)

        cost_gradient_x() (see CostFuncDiff class)

        residual_x()

        jacobian_x()

        residual_jacobian_x()

        If the parameters are already set, then this method returns the
        residual of the NLLS problem at the current set point.

        The size of the residual vector can be obtained in advance by calling
        residual_size().

        The residual of the NLLS problem 
        """
        return _nlls_problem.NLLSProblem__v_residual(self)


    @property
    def residual(self):
        return self._v_residual()


    def residual_x(self, x):
        """

        virtual blitz::Array<double, 1> FullPhysics::NLLSProblem::residual_x(const blitz::Array< double, 1 > &x)
        The residual function with parameters.

        This method also evaluates the residual of the NLLS problem; however,
        it sets the problem at the input new point and then evaluates the
        residual.

        The size of the residual vector can be obtained in advance by calling
        residual_size().

        Parameters:
        -----------

        x:  New set of parameters

        The residual of the cost function 
        """
        return _nlls_problem.NLLSProblem_residual_x(self, x)


    def _v_jacobian(self):
        """

        virtual blitz::Array<double, 2> FullPhysics::NLLSProblem::jacobian()=0
        The Jacobian matrix function.

        This method must be implemented by the classes derived from this
        class.

        The parameters (the point in the parameter space) must have already
        been set before calling this method. The parameters are already set if
        one of the following methods is already called successfully:
        parameters() (see ProblemState class)

        cost_x() (see CostFunc class)

        gradient_x() (see CostFuncDiff class)

        cost_gradient_x() (see CostFuncDiff class)

        residual_x()

        jacobian_x()

        residual_jacobian_x()

        If the parameters are already set, then this method returns the
        Jacobian of the residual of the NLLS problem at the current set point.

        The sizes of the Jacobian matrix can be obtained in advance: The
        number of its rows is the same as residual_size().

        The number of its columns is the same as
        ProblemState::expected_parameter_size() or
        CostFuncDiff::gradient_size()

        The Jacobian of the residual of the NLLS problem 
        """
        return _nlls_problem.NLLSProblem__v_jacobian(self)


    @property
    def jacobian(self):
        return self._v_jacobian()


    def jacobian_x(self, x):
        """

        virtual blitz::Array<double, 2> FullPhysics::NLLSProblem::jacobian_x(const blitz::Array< double, 1 > &x)
        The Jacobian function with parameters.

        This method also evaluates the Jacobian of the residual of the NLLS
        problem; however, it sets the problem at the input new point and then
        evaluates the Jacobian.

        The sizes of the Jacobian matrix can be obtained in advance as
        mentioned in the comments on jacobian() method.

        Parameters:
        -----------

        x:  New set of parameters

        The Jacobian of the residual of the NLLS problem 
        """
        return _nlls_problem.NLLSProblem_jacobian_x(self, x)


    def residual_jacobian(self):
        """

        virtual void FullPhysics::NLLSProblem::residual_jacobian(blitz::Array< double, 1 > &r, blitz::Array< double, 2 > &j)
        The residual function and its Jacobian together.

        This method passes to the caller the evaluated residual function and
        its Jacobian at the current set point.

        The parameters (the point in the parameter space) must have already
        been set before calling this method. The parameters are already set if
        one of the following methods is already called successfully:
        parameters() (see ProblemState class)

        cost_x() (see CostFunc class)

        gradient_x()

        cost_gradient_x()

        residual_x()

        jacobian_x()

        residual_jacobian_x()

        Parameters:
        -----------

        r:  The residual vector

        j:  The Jacobian matrix 
        """
        return _nlls_problem.NLLSProblem_residual_jacobian(self)


    def residual_jacobian_x(self, x):
        """

        virtual void FullPhysics::NLLSProblem::residual_jacobian_x(const blitz::Array< double, 1 > &x, blitz::Array< double, 1 > &r,
        blitz::Array< double, 2 > &j)
        The residual and its Jacobian with parameters.

        This method passes to the caller the evaluated residual function and
        its Jacobian after setting the problem at the input new point.

        Parameters:
        -----------

        x:  New set of parameters

        r:  The residual vector

        j:  The Jacobian matrix 
        """
        return _nlls_problem.NLLSProblem_residual_jacobian_x(self, x)


    def _v_num_residual_evaluations(self):
        """

        virtual int FullPhysics::NLLSProblem::num_residual_evaluations() const
        Returns the number of the times residual has been evaluated.

        The number of the times residual has been evaluated 
        """
        return _nlls_problem.NLLSProblem__v_num_residual_evaluations(self)


    @property
    def num_residual_evaluations(self):
        return self._v_num_residual_evaluations()


    def _v_num_jacobian_evaluations(self):
        """

        virtual int FullPhysics::NLLSProblem::num_jacobian_evaluations() const
        Returns the number of the times Jacobian has been evaluated.

        The number of the times Jacobian has been evaluated 
        """
        return _nlls_problem.NLLSProblem__v_num_jacobian_evaluations(self)


    @property
    def num_jacobian_evaluations(self):
        return self._v_num_jacobian_evaluations()


    def _v_residual_size(self):
        """

        virtual int FullPhysics::NLLSProblem::residual_size() const =0
        The size of the residual returned by residual()

        This method must be implemented by the classes derived from this
        class.

        The size of the residual that will be returned by residual() 
        """
        return _nlls_problem.NLLSProblem__v_residual_size(self)


    @property
    def residual_size(self):
        return self._v_residual_size()

NLLSProblem_swigregister = _nlls_problem.NLLSProblem_swigregister
NLLSProblem_swigregister(NLLSProblem)

# This file is compatible with both classic and new-style classes.


